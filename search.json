[{"title":"[title]","url":"/2018/08/07/title/"},{"title":"Hello World","url":"/2018/08/07/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"url":"/2018/07/31/IOS知识点汇总/","content":"# IOS知识点汇总\n## 第三方开源项目\n### 响应式编程\n* [Swift-ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n* [RxSwift](https://github.com/ReactiveX/RxSwift)\n\n#### [AFNetworking -- 功能非常齐全的网络数据请求库，侧重于处理各种类型的api风格,提供了远程图片异步加载，上传下载等常用功能，如果项目数据量很小它会是很好的选择](https://github.com/AFNetworking/AFNetworking)\n* POST\n* GET\n\n#### [SDWebImage -- 图片异步加载](https://github.com/rs/SDWebImage)\n\n* 特点\n   * 不阻塞主线程\n   * 异步加载图片，不重复获取图片URL\n   * 后台图片解压缩\n   * 高性能\n   * 使用GCD和ARC\n   * 支持多种图片格式，包括GIF\n   * 提供 UIImageView, UIButton, MKAnnotationView 的分类，用来显示网络图片，以及缓存管理\n   * 异步缓存（内存+磁盘），并且自动管理缓存有效性\n \n ***\n   * 使用方法，常用：UIImageView+WebCache\n ```\n [self.imageView sd_setImageWithURL:[NSURL URLWithString:@\"图片链接\"] placeholderImage:[UIImage imageNamed:@\"默认图片\"]];\n ```\n \n   * 使用回调 blocks\n   \n  ```\n  [self.imageView sd_setImageWithURL:[NSURL URLWithString:@\"图片链接\"]\n                      placeholderImage:[UIImage imageNamed:@\"默认图片\"]\n                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {\n                                 ... completion code here ...\n                             }];\n  ```\n  \n   *  SDWebImageManager 的使用(将图片下载和图片缓存组合起来了,也可以单独使用)\n\n   ```\n   SDWebImageManager *manager = [SDWebImageManager sharedManager];\n[manager loadImageWithURL:imageURL\n                      options:0\n                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {\n                         // progression tracking code\n                     }\n                    completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {\n                        if (image) {\n                            // do something with image\n                        }\n                    }];\n   ```\n   \n   * 使用 SDWebImageDownloader 异步下载图片(单独使用，图片不会缓存)\n\n   ```\n   SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];\n[downloader downloadImageWithURL:imageURL\n                             options:0\n                            progress:^(NSInteger receivedSize, NSInteger expectedSize) {\n                                // progression tracking code\n                            }\n                           completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {\n                               if (image && finished) {\n                                   // do something with image\n                               }\n                           }];\n   ```\n   \n   * 使用 SDImageCache 异步缓存图片(单独使用时，可使用单例，也可以创建一个有独立命名空间的 SDImageCache 实例)\n      * 添加缓存\n      \n   ```\n   [[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];\n   ```\n   \n      * 默认情况下，图片数据会同时缓存到内存和磁盘中，如果你想只要内存缓存的话\n      \n      ```\n      [[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey toDisk:NO];\n      ```\n      * 读取缓存时可以使用 queryDiskCacheForKey:done: 方法，图片缓存的 key 是唯一的，通常就是图片的 absolute URL\n\n      ```\n      SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@\"myNamespace\"];\n[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image) {\n        // image is not nil if image was found\n    }];\n      ```\n ***\n\n#### [OC-GPUImage -- 做滤镜最主流的开源框架](https://github.com/BradLarson/GPUImage)\n\n***\n* GPUImage中的几个概念(output为输出源,intput为输入源,filter为滤镜)\n   * #import \"GPUImageBrightnessFilter.h\"                //亮度\n   * #import \"GPUImageExposureFilter.h\"                  //曝光\n   * #import \"GPUImageContrastFilter.h\"                  //对比度\n   * #import \"GPUImageSaturationFilter.h\"                //饱和度\n   * #import \"GPUImageGammaFilter.h\"                     //伽马线\n   * #import \"GPUImageColorInvertFilter.h\"               //反色\n   * #import \"GPUImageSepiaFilter.h\"                     //褐色（怀旧）\n   * #import \"GPUImageLevelsFilter.h\"                    //色阶\n   * #import \"GPUImageGrayscaleFilter.h\"                 //灰度\n   * #import \"GPUImageHistogramFilter.h\"                 //色彩直方图，显示在图片上\n   * #import \"GPUImageHistogramGenerator.h\"              //色彩直方图\n   * #import \"GPUImageRGBFilter.h\"                       //RGB\n   * #import \"GPUImageToneCurveFilter.h\"                 //色调曲线\n   * #import \"GPUImageMonochromeFilter.h\"                //单色\n   * #import \"GPUImageOpacityFilter.h\"                   //不透明度\n   * #import \"GPUImageHighlightShadowFilter.h\"           //提亮阴影\n   * #import \"GPUImageFalseColorFilter.h\"                //色彩替换（替换亮部和暗部色彩）\n   * #import \"GPUImageHueFilter.h\"                       //色度\n   * #import \"GPUImageChromaKeyFilter.h\"                 //色度键\n   * #import \"GPUImageWhiteBalanceFilter.h\"              //白平横\n   * #import \"GPUImageAverageColor.h\"                    //像素平均色值\n   * #import \"GPUImageSolidColorGenerator.h\"             //纯色\n   * #import \"GPUImageLuminosity.h\"                      //亮度平均\n   * #import \"GPUImageAverageLuminanceThresholdFilter.h\" //像素色值亮度平均，图像黑白（有类似漫画效果）\n   * #import \"GPUImageLookupFilter.h\"                    //lookup 色彩调整\n   * #import \"GPUImageAmatorkaFilter.h\"                  //Amatorka lookup\n   * #import \"GPUImageMissEtikateFilter.h\"               //MissEtikate lookup\n   * #import \"GPUImageSoftEleganceFilter.h\"              //SoftElegance lookup\n   * #import \"GPUImageCrosshairGenerator.h\"              //十字\n   * #import \"GPUImageLineGenerator.h\"                   //线条\n   * #import \"GPUImageTransformFilter.h\"                 //形状变化\n   * #import \"GPUImageCropFilter.h\"                      //剪裁\n   * #import \"GPUImageSharpenFilter.h\"                   //锐化\n   * #import \"GPUImageUnsharpMaskFilter.h\"               //反遮罩锐化\n   * #import \"GPUImageFastBlurFilter.h\"                  //模糊\n   * #import \"GPUImageGaussianBlurFilter.h\"              //高斯模糊\n   * #import \"GPUImageGaussianSelectiveBlurFilter.h\"     //高斯模糊，选择部分清晰\n   * #import \"GPUImageBoxBlurFilter.h\"                   //盒状模糊\n   * #import \"GPUImageTiltShiftFilter.h\"                 //条纹模糊，中间清晰，上下两端模糊\n   *  #import \"GPUImageMedianFilter.h\"                    //中间值，有种稍微模糊边缘的效果\n   * #import \"GPUImageBilateralFilter.h\"                 //双边模糊\n   * #import \"GPUImageErosionFilter.h\"                   //侵蚀边缘模糊，变黑白\n   * #import \"GPUImageRGBErosionFilter.h\"                //RGB侵蚀边缘模糊，有色彩\n   * #import \"GPUImageDilationFilter.h\"                  //扩展边缘模糊，变黑白\n   * #import \"GPUImageRGBDilationFilter.h\"               //RGB扩展边缘模糊，有色彩\n   * #import \"GPUImageOpeningFilter.h\"                   //黑白色调模糊\n   * #import \"GPUImageRGBOpeningFilter.h\"                //彩色模糊\n   * #import \"GPUImageClosingFilter.h\"                   //黑白色调模糊，暗色会被提亮\n   * #import \"GPUImageRGBClosingFilter.h\"                //彩色模糊，暗色会被提亮\n   * #import \"GPUImageLanczosResamplingFilter.h\"         //Lanczos重取样，模糊效果\n   * #import \"GPUImageNonMaximumSuppressionFilter.h\"     //非最大抑制，只显示亮度最高的像素，其他为黑\n   * #import \"GPUImageThresholdedNonMaximumSuppressionFilter.h\" //与上相比，像素丢失更多\n   * #import \"GPUImageSobelEdgeDetectionFilter.h\"        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)\n   * #import \"GPUImageCannyEdgeDetectionFilter.h\"        //Canny边缘检测算法（比上更强烈的黑白对比度）\n   * #import \"GPUImageThresholdEdgeDetectionFilter.h\"    //阈值边缘检测（效果与上差别不大）\n   * #import \"GPUImagePrewittEdgeDetectionFilter.h\"      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)\n   * #import \"GPUImageXYDerivativeFilter.h\"              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色\n   * #import \"GPUImageHarrisCornerDetectionFilter.h\"     //Harris角点检测，会有绿色小十字显示在图片角点处\n   * #import \"GPUImageNobleCornerDetectionFilter.h\"      //Noble角点检测，检测点更多\n   * #import \"GPUImageShiTomasiFeatureDetectionFilter.h\" //ShiTomasi角点检测，与上差别不大\n   * #import \"GPUImageMotionDetector.h\"                  //动作检测\n   * #import \"GPUImageHoughTransformLineDetector.h\"      //线条检测\n   * #import \"GPUImageParallelCoordinateLineTransformFilter.h\" //平行线检测\n   * #import \"GPUImageLocalBinaryPatternFilter.h\"        //图像黑白化，并有大量噪点\n   * #import \"GPUImageLowPassFilter.h\"                   //用于图像加亮\n   * #import \"GPUImageHighPassFilter.h\"                  //图像低于某值时显示为黑\n   * #import \"GPUImageSketchFilter.h\"                    //素描\n   * #import \"GPUImageThresholdSketchFilter.h\"           //阀值素描，形成有噪点的素描\n   * #import \"GPUImageToonFilter.h\"                      //卡通效果（黑色粗线描边）\n   * #import \"GPUImageSmoothToonFilter.h\"                //相比上面的效果更细腻，上面是粗旷的画风\n   * #import \"GPUImageKuwaharaFilter.h\"                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用\n   * #import \"GPUImageMosaicFilter.h\"                    //黑白马赛克\n   * #import \"GPUImagePixellateFilter.h\"                 //像素化\n   * #import \"GPUImagePolarPixellateFilter.h\"            //同心圆像素化\n   * #import \"GPUImageCrosshatchFilter.h\"                //交叉线阴影，形成黑白网状画面\n   * #import \"GPUImageColorPackingFilter.h\"              //色彩丢失，模糊（类似监控摄像效果）\n   * #import \"GPUImageVignetteFilter.h\"                  //晕影，形成黑色圆形边缘，突出中间图像的效果\n   * #import \"GPUImageSwirlFilter.h\"                     //漩涡，中间形成卷曲的画面\n   * #import \"GPUImageBulgeDistortionFilter.h\"           //凸起失真，鱼眼效果\n   * #import \"GPUImagePinchDistortionFilter.h\"           //收缩失真，凹面镜\n   * #import \"GPUImageStretchDistortionFilter.h\"         //伸展失真，哈哈镜\n   * #import \"GPUImageGlassSphereFilter.h\"               //水晶球效果\n   * #import \"GPUImageSphereRefractionFilter.h\"          //球形折射，图形倒立\n   * #import \"GPUImagePosterizeFilter.h\"                 //色调分离，形成噪点效果\n   * #import \"GPUImageCGAColorspaceFilter.h\"             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面\n   * #import \"GPUImagePerlinNoiseFilter.h\"               //柏林噪点，花边噪点\n   * #import \"GPUImage3x3ConvolutionFilter.h\"            //3x3卷积，高亮大色块变黑，加亮边缘、线条等\n   * #import \"GPUImageEmbossFilter.h\"                    //浮雕效果，带有点3d的感觉\n   * #import \"GPUImagePolkaDotFilter.h\"                  //像素圆点花样\n   * #import \"GPUImageHalftoneFilter.h\"                  //点染,图像黑白化，由黑点构成原图的大致图形\n   * #import \"GPUImageMultiplyBlendFilter.h\"             //通常用于创建阴影和深度效果\n   * #import \"GPUImageNormalBlendFilter.h\"               //正常\n   * #import \"GPUImageAlphaBlendFilter.h\"                //透明混合,通常用于在背景上应用前景的透明度\n   * #import \"GPUImageDissolveBlendFilter.h\"             //溶解\n   * #import \"GPUImageOverlayBlendFilter.h\"              //叠加,通常用于创建阴影效果\n   * #import \"GPUImageDarkenBlendFilter.h\"               //加深混合,通常用于重叠类型\n   * #import \"GPUImageLightenBlendFilter.h\"              //减淡混合,通常用于重叠类型\n   * #import \"GPUImageSourceOverBlendFilter.h\"           //源混合\n   * #import \"GPUImageColorBurnBlendFilter.h\"            //色彩加深混合\n   * #import \"GPUImageColorDodgeBlendFilter.h\"           //色彩减淡混合\n   * #import \"GPUImageScreenBlendFilter.h\"               //屏幕包裹,通常用于创建亮点和镜头眩光\n   * #import \"GPUImageExclusionBlendFilter.h\"            //排除混合\n   * #import \"GPUImageDifferenceBlendFilter.h\"           //差异混合,通常用于创建更多变动的颜色\n   * #import \"GPUImageSubtractBlendFilter.h\"             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果\n   * #import \"GPUImageHardLightBlendFilter.h\"            //强光混合,通常用于创建阴影效果\n   * #import \"GPUImageSoftLightBlendFilter.h\"            //柔光混合\n   * #import \"GPUImageChromaKeyBlendFilter.h\"            //色度键混合\n   * #import \"GPUImageMaskFilter.h\"                      //遮罩混合\n   * #import \"GPUImageHazeFilter.h\"                      //朦胧加暗\n   * #import \"GPUImageLuminanceThresholdFilter.h\"        //亮度阈\n   * #import \"GPUImageAdaptiveThresholdFilter.h\"         //自适应阈值\n   * #import \"GPUImageAddBlendFilter.h\"                  //通常用于创建两个图像之间的动画变亮模糊效果\n   * #import \"GPUImageDivideBlendFilter.h\"               //通常用于创建两个图像之间的动画变暗模糊效果\n   * #import \"c.h\"\n   * #import \"GPUImageVoroniConsumerFilter.h\"\n\n***\n\n#### [Swift-GPUImage](https://github.com/BradLarson/GPUImage2)\n\n#### [Masonry -- 自动约束](https://github.com/SnapKit/Masonry)\n##### 采用链式编程的方法\n***\n* mas_makeConstraints()    添加约束\n* mas_remakeConstraints()  移除之前的约束，重新添加新的约束（ __调用此方法的时候，使用了如下API__）\n   * - (void)setNeedsLayout  标记为需要重新布局\n   * - (void)layoutIfNeeded  查看当前视图是否被标记需要重新布局，有则在内部调用layoutSubviews方法进行重新布局\n   * - (void)layoutSubviews  重写当前方法，在内部完成重新布局操作\n\n   \n* mas_updateConstraints()  更新约束（ __调用此方法时所使用到的API如下__ ）\n   * - (void)updateConstraintsIfNeeded  调用此方法，如果有标记为需要重新布局的约束，则立即进行重新布局，内部会调用updateConstraints方法\n   * - (void)updateConstraints          重写此方法，内部实现自定义布局过程\n   * - (BOOL)needsUpdateConstraints     当前是否需要重新布局，内部会判断当前有没有被标记的约束\n   * - (void)setNeedsUpdateConstraints  标记需要进行重新布局\n\n***\n##### 注：在使用Masonry添加约束的时候，一定要在addSubview之后再使用，要不然会引起程序的崩溃现象\n\n####[RestKit -- 注重从远程数据请求到本地数据解析的存储和流程化业务处理，它专注于RESTful API，如果你项目服务器不是RESTful，那就别考虑了](https://github.com/RestKit/RestKit)\n* 解析json和映射对象\n* Network :RestKit现在使用AFNetworking v1.3.3作为网络操作层，RestKit的维护者正在升级到AFNetworking 2.0\n* Object Mapping(对象映射): RestKit提供一个接口来直接映射服务器返回的json/xml数据\n* Core Data:RestKit对coreData提供了额外的支持，包括映射远程对象为coreData对象并且进行本地存储\n\n***\n* RKObjectManager是和RESTful services交互的核心,需要一个AFHTTPClient实例来进行初始化。\n\n* RKObjectMapping是用来配置JSON和本地model的映射信息，如果json和本地的model中都有name这个字段，你又需要解析这个字段，那么就要通过addAttributeMappingsFromArray进行添加。\n\n* RKResponseDescriptor描述了对HTTP返回数据的映射信息。pathPattern 就是api的具体路径，会被添加到baseURL后面。keyPath 是对象在json数据中的路径。看看上面的json数据,@“response.venues”说明了对象venue所处的逻辑位置，并告诉RestKit去哪找venue。\n\n***\n\n\n\n#### [YYKit](https://github.com/ibireme/YYKit)\n\n* [YYModel — 高性能的 iOS JSON 模型框架。](https://github.com/ibireme/YYModel)\n* [YYCache — 高性能的 iOS 缓存框架。](https://github.com/ibireme/YYCache)\n* [YYImage — 功能强大的 iOS 图像框架。](https://github.com/ibireme/YYImage)\n* [YYWebImage — 高性能的 iOS 异步图像加载框架。](https://github.com/ibireme/YYWebImage)\n* [YYText — 功能强大的 iOS 富文本框架。](https://github.com/ibireme/YYText)\n* [YYKeyboardManager — iOS 键盘监听管理工具。](https://github.com/ibireme/YYKeyboardManager)\n* [YYDispatchQueuePool — iOS 全局并发队列管理工具。](https://github.com/ibireme/YYDispatchQueuePool)\n* [YYAsyncLayer — iOS 异步绘制与显示的工具。](https://github.com/ibireme/YYAsyncLayer)\n* [YYCategories — 功能丰富的 Category 类型工具库。](https://github.com/ibireme/YYCategories)\n\n#### [FMDB -- 数据库](https://github.com/ccgus/fmdb)\n__对libsqlite3库的封装__\n\n#### [RESideMenu -- 侧滑栏](https://github.com/romaonthego/RESideMenu)\n\n#### [UITableView - FDTemplateLayoutCell -- 缓存cell高度-自适应](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)\n__可与Masonry搭配使用__\n\n#### [IQKeyBoardManager -- 自定义键盘](https://github.com/hackiftekhar/IQKeyboardManager)\n\n#### [WMPageController -- 自定义滚动菜单栏](https://github.com/wangmchn/WMPageController)\n\n#### [LemonBubble -- 自定义弹框样式](https://github.com/LemonITCN/LemonBubble)\n\n#### [MJRefresh -- 刷新加载](https://github.com/CoderMJLee/MJRefresh)\n\n### JSON\n* MJExtension\n* JSONModel\n* YYModel\n\n\n### XML\n* Ono\n* GDataXML\n* XMLDictionary\n* hpple\n* KissXML\n\n## 工具\n### IDE\n* Xcode\n* Appcode\n\n### Xcode插件\n* AMMethod2Implement\n* Alcatraz\n* ClangFormat\n* Auto-Importer\n* CocoaPods\n* ESJsonFormat\n* FuzzyAutocimplete\n* KSHObjcUML\n* KSImageNamed\n* OMColorSense\n* RTImageAssets\n* SCXcodeSwitchExpander\n* VVDocumenter-Xcode\n* Lin\n* XAlign\n* HOStringSense\n* XToDo\n* XcodeBoost\n* BBUDebuggerTuckAway\n* InjectionPlugin\n\n### 调试工具\n* 界面\n   * Reveal\n   * Xcode内置的View Debugging\n* 网络\n   * WireShark\n   * Charles\n   * Network Link Condidtioner\n   * HTTPScoop\n   * PonyDebugger\n\n### 数据分析工具\n* 数据库\n   * SQLiteBrowser\n   * Navicat\n   * Datum\n* JSON\n   * Jason\n   * VisualJson\n   * json.cn\n\n### 文档工具\n* Dash\n* Xcode内置的Documentation And API Reference\n\n### 应用程序图标\n* APPIcon\n* IconKit\n* Image 2 Icon Tool\n\n### 界面原型\n* Sketch\n* 墨刀\n* Briefs\n* Axure RP\n\n### 性能分析\n* Instruments\n   * Allocations\n   * Network\n   * Leaks\n   * Time Profiler\n   * Zombie\n\n### 包管理工具\n* CocoaPods\n* Carthage\n* Swift Package Manager\n\n### 版本控制\n* Git\n   * SourceTree\n   * Github Desktop\n   * GitUp \n* Mercurial\n* SVN\n   * CornerStone\n\n### 编辑工具\n* Markdown\n   * MacDown\n   * Haroopad\n   * Typora\n   * MWeb\n* 文本编辑器\n   * Atom\n   * Sublime Text\n   * Visual Studio Code\n\n### 翻墙工具\n* Lantern\n* Shadowsocks\n* GoAgentX\n* Surge\n\n### 辅助工具\n* Unarchiver\n* 截图工具\n   * GIFBrewery\n   * Snip\n   * LICEcap\n* 图片处理\n   * PhotoShop\n   * PixeImator\n* Sip\n* XScope\n* 思维导图\n   * MindNode\n   * Xmind\n* 马克鳗\n* 文本比较\n   * DiffMerge\n   * Beyond Compare\n* ImageOptim\n* Deploymate\n* FauxPas\n* 0xED\n* UML/在线UML\n### 命令行工具\n* xcodebuild\n* xcode-select\n* brew\n* xctool\n* fastlane\n* git-flow\n* tree\n\n## 第三方服务\n### BasS(后端即服务)\n* LeanCloud\n* Bomb\n* 七牛\n* 环信\n* 融云\n* 友盟\n* CloudKit\n* 极光推送\n* Flurry\n* Google Analytics\n* MTA\n* App Annie\n\n### 崩溃收集\n* Crashlytics\n* Bugly\n* BugHD\n\n### 内测分发\n* 蒲公英\n* FIR\n* TestFlight\n\n## 持续集成\n* Travis CI\n* Circle CI\n* Coveralls\n* Codecov\n* Fastlane(自动化发布流程)\n\n## 编程语言\n* C/C++\n* Objective-C\n* Swift\n* HTML5\n* JavaScript\n\n## 操作系统\n* macOS\n* ios\n* WatchOS\n* TV OS\n* Linus常用命令\n\n## 开发基础\n### Objective-C\n* Block\n* 类的设计\n   * Self\n   * 属性\n   * 组合\n   * 重写\n   * 继承\n   * 多态\n   * Category\n   * Extension\n   * Protocol\n   * Class\n   * SEL\n* 文件管理\n* 内存管理\n   * MRC\n   * ARC\n* 数据持久化\n   * XML\n   * Plist\n   * 归档\n   * CoreData & SQLite\n   * JSON\n* KVC&KVO\n* Foundation\n\n\n### Swift\n* 基本运算符\n* 字符串和字符\n* 集合类型\n* 控制流\n* 函数\n* 闭包\n* 枚举\n* 类和结构体\n* 属性\n* 方法\n* 下标脚本\n* 继承\n* 构造过程\n* 析构过程\n* 自动引用计数\n* 可空链式调用\n* 错误处理\n* 类型转换\n* 嵌套类型\n* 扩展\n* 协议\n* 泛型\n* 访问控制\n\n\n### UI\n* UIResponder\n   * UIApplication\n   * UIView\n      * MapKit\n         * MKAnnotationView\n         * MKMapView\n         * MKOverlayView\n         * MPVolumeView\n      * UIKit\n         * UIActionSheet\n         * UIAlertView\n         * UIActivityInndicatorView\n         * UIControl\n            * UIDatePicker\n            * UIButton\n            * UIPageControl\n            * UIRefreshControl\n            * UISegmentedControl\n            * UISlider\n            * UIStepper\n            * UISwitch\n            * UITextField\n         * UIInputView\n         * UIImageView\n         * UILabel\n         * UINavigationBar\n         * UIPopoverBackgroundView\n         * UIPickerView\n         * UIProgressView\n         * UIScrollView\n            * UICollectionView\n            * UITableView\n            * UITextView -- UITextField\n         * UISearchBar\n         * UIStackView\n         * UITabBar\n         * UITableViewCell\n         * UITableView\bHeaderFooterView\n         * UIToolBar\n         * UIWebView\n         * UIVisualEffectView\n         * UIWindow\n      * WebKit - WKWebView\n   * UIViewController\n      * AddressBookUI\n         * ABNewPersonViewController\n         * ABPersonViewController\n         * ABUnknownPersonViewController\n      * UIKit\n         * UIActivityViewController\n         * UIAlertController\n         * UICollectionViewController\n         * UISearchContainerViewController\n         * UIInputViewController\n         * UINavigationController -- UIImagePickerController\n         * UIPageViewController\n         * UISearchController\n         * UISplitViewController\n         * UITabBarController\n         * UIPopoverController(非继承)\n         * UITableViewController\n         * UISearchDisplayController (非继承)\n         * UIMenuController (非继承)\n      * AVKit\n         * AVPlayerViewController\n         * AVPictureInPictureController (非继承)\n* Storyboard & Xib\n   * Auto Layout\n      * SnapKit\n      * Masonry\n   * Size Classes\n* Core Graphics\n* Core Animation\n* 手势识别\n   * UIPanGestureRecognizer -- 平移/慢速移动手势\n   * UILongPressGestureRecognizer -- 长按手势\n   * UIPinchGestureRecognizer -- 捏合手势\n   * UIRotationGestureRecognizer -- 旋转手势\n   * UITapGestureRecognizer  -- 点击手势\n   * UISwipGestureRecognizer  -- 滑动/移动手势\n\n```\n#import \"FourthViewController.h\"\n\n@interface FourthViewController ()<UIGestureRecognizerDelegate>\n\n@property (nonatomic, strong)UIImageView * imageView;\n@end\n\n@implementation FourthViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [super setNavigationBarColor:Main_Color title:@\"发现\" TitleColor:Color_white];\n    \n    self.imageView = insertAutoImage(self.view, Img_Name(@\"gep\"), Color_clear);\n    [self.imageView mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.view.mas_left).offset(60);\n        make.right.equalTo(self.view.mas_right).offset(-60);\n        make.bottom.equalTo(self.view.mas_bottom).offset(-60);\n        make.top.equalTo(self.view.mas_top).offset(60);\n    }];\n    \n    //允许和用户之间进行交互\n    self.imageView.userInteractionEnabled = YES;\n    //添加手势\n    //1.旋转手势\n    UIRotationGestureRecognizer * gestureOne = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(gestureClick:)];\n    gestureOne.delegate = self;\n    [self.imageView addGestureRecognizer:gestureOne];\n    \n    //2.捏合手势\n    UIPinchGestureRecognizer * gestureTwo = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(gestureTwoClick:)];\n    gestureTwo.delegate = self;\n    [self.imageView addGestureRecognizer:gestureTwo];\n    \n    //3.滑动手势\n    UISwipeGestureRecognizer * gestureThree1 = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(gestureThreeClick:)];\n    gestureThree1.direction = UISwipeGestureRecognizerDirectionRight;\n    [self.imageView addGestureRecognizer:gestureThree1];\n    \n    UISwipeGestureRecognizer * gestureThree2 = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(gestureThreeClick:)];\n    gestureThree2.direction = UISwipeGestureRecognizerDirectionLeft;\n    [self.imageView addGestureRecognizer:gestureThree2];\n    \n    //4.点击手势\n    UITapGestureRecognizer * gestureFour = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(gestureFourClick:)];\n    gestureFour.numberOfTapsRequired = 1;//点击次数\n    [self.imageView addGestureRecognizer:gestureFour];\n    \n    //5.长按手势\n    UILongPressGestureRecognizer * gestureFif = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(gestureFifClick:)];\n    gestureFif.minimumPressDuration = 1;//长按时间\n    [self.view addGestureRecognizer:gestureFif];\n    \n}\n#pragma mark - 旋转手势 -\n- (void)gestureClick:(UIRotationGestureRecognizer *)sender {\n    self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, sender.rotation);\n    sender.rotation = 0;//每次旋转完后清0，防止叠加\n}\n#pragma mark - 捏合手势 -\n- (void)gestureTwoClick:(UIPinchGestureRecognizer *)sender {\n    self.imageView.transform = CGAffineTransformScale(self.imageView.transform, sender.scale, sender.scale);\n    sender.scale = 1;\n}\n#pragma mark - 滑动手势 -\n- (void)gestureThreeClick:(UISwipeGestureRecognizer *)sender {\n    if (sender.direction == UISwipeGestureRecognizerDirectionRight) {\n        self.imageView.center = CGPointMake(SCREEN_WIDTH/2+20, SCREEN_HEIGHT/2);\n    }\n    if (sender.direction == UISwipeGestureRecognizerDirectionLeft) {\n        self.imageView.center = CGPointMake(SCREEN_WIDTH/2-20, SCREEN_HEIGHT/2);\n    }\n}\n#pragma mark - 点击手势 -\n- (void)gestureFourClick:(UITapGestureRecognizer *)sender {\n    //点击放大/缩小图片\n    [self.imageView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.view.mas_left).offset(10);\n        make.right.equalTo(self.view.mas_right).offset(-10);\n        make.bottom.equalTo(self.view.mas_bottom).offset(-10);\n        make.top.equalTo(self.view.mas_top).offset(10);\n    }];\n}\n#pragma mark - 长按手势 -\n- (void)gestureFifClick:(UILongPressGestureRecognizer *)sender {\n    //获取长按的位置在屏幕上对应的点\n    CGPoint point  = [sender locationInView:self.view];\n    self.imageView.center = point;\n}\n//返回YES表示同时支持识别多个手势\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{\n    return YES;\n    \n}\n@end\n```\n\n### 网络\n* Socket\n   * CocoaAsyncSocket\n   * WebSocket -- SocketRocket\n* 网络协议\n   * TCP\n   * UDP\n   * HTTP\n   * HTTPS\n* NSURLSession\n* NSURLConnection\n* CFNetwork\n* NSSream\n### 多线程\n* pThread\n* NSThread\n* GCD\n   * 同步\n   * 异步\n   * 串行\n   * 并发\n* NSTunLoop\n* NSOperationQueue\n\n\n### 测试\n* 断点调试\n* LLDB\n* GDB\n* NSZombieEnabled\n* Instruments\n* Unit Tests\n* UI Tests\n\n\n### 数据存储\n* Plist -- NSUserDefaults\n* NSCoder\n* SQLite -- CoreData\n   * 特点\n      * 1.是基于c语言开发的数据库\n      * 2.用c语言对数据库执行操作，访问。\n      * 3.sqlite是动态的数据库类型，即存储的时候是一种类型，使用的时候可以存储为其他类型。\n      * 4.建立连接之后可以不关闭连接\n* Realm\n* KeyChain\n\n## Frameworks\n### 常用框架\n* 音视频\n   * AudioToolbox\n   * AVFoundation\n   * AVKit\n   * CoreAudio\n   * CoreAudioKit\n   * MediaPlayer\n* 定位地图\n   * CoreLocation\n   * MapKit\n* 网页\n   * WebKit\n   * JavaScript Core\n      * WebViewJavaScriptBridge\n      * Wax\n      * JSPatch\n* 通讯录\n   * AddressBook\n   * AddressBookUI\n* 相册\n   * AssetsLibrary\n* 数据存储\n   * CoreData\n   * CloudKit\n* 图文混排\n   * CoreText\n* 本地验证\n   * LocalAuthentication\n* 支付\n   * StoreKit\n   * PassKit\n\n   \n### 高级框架\n* 智能家居\n   * Home Kit\n* 健康\n   * Health Kit\n* 广告\n   * AdSupport\n   * iAd\n* 硬件开发\n   * MutilpeerConnectivity\n   * CoreBluetooth\n   * CoreMotion\n* 游戏开发\n   * GameKit\n   * SpriteKit\n* 绘图\n   * CoreGrapthics(2D)\n   * QuartzCore\n   * SceneKit(3D)\n   * Metal\n\n## 开发进阶\n### Runtime\n### 对象模型\n### 逆向与安全\n* 转码技术\n   * URL Encode\n   * Base64 Encode\n* 密码技术\n   * 对称密码\n      * DES/3DES\n      * AES\n   * 公钥密码\n      * RSA\n   * 单向散列函数\n      * MD5\n      * SHA\n         * SHA-1\n         * SHA-224\n         * SHA-256\n         * SHA-384\n         * SHA-512\n      * HMAC\n      * PBKDF2\n\n### Hybrid\n* PhoneGap\n* React Native\n* ionic\n\n\n### 打包与封装\n* App Thinning\n* 动态库 .dylib\n* 框架 .framework\n* 静态库 .a\n* 资源包 .bundle\n\n\n## 设计模式\n### 面向对象三要素\n* 封装\n* 继承\n* 多态\n\n\n### 面向对象七原则\n* L:里式替换原则\n* S:单一职责原则\n* I:接口隔离原则\n* O:开放封闭原则\n* D:依赖倒置原则\n* 迪米特法则 -- 最少知道原则\n* 合成聚合复用原则\n\n\n### 23种设计模式(四人帮)\n* 创建型模式\n   * 工厂模式(Factory Pattern)\n   * 抽象工厂模式(Abstract Factory Pattern)\n   * 单例模式(Singleton Pattern)\n   * 建造者模式(Builder Pattern)\n   * 原型模式(Prototype Pattern)\n* 结构型模式\n   * 适配器模式(Adapter Pattern)\n   * 桥接模式(Bridge Pattern)\n   * 组合模式(Composite Pattern)\n   * 过滤器模式(Filter、Criteria Pattern)\n   * 装饰器模式(Decorator Pattern)\n   * 外观模式(Facade Pattern)\n   * 享元模式(Flyweight Pattern)\n   * 代理模式(Proxy Pattern)\n* 行为型模式\n   * 责任链模式(Chain of Responsibility Pattern)\n   * 命令模式(Command Pattern)\n   * 解释器模式(Interpreter Pattern)\n   * 迭代器模式(Iterator Pattern)\n   * 中介者模式(Mediator Pattern)\n   * 备忘录模式(Memento Pattern)\n   * 观察者模式(Observer Pattern)\n   * 空对象模式(Null Object Pattern)\n   * 状态模式(State Pattern)\n   * 策略模式(Strategy Pattern)\n   * 模板模式(Template Pattern)\n   * 访问者模式(Visitor Pattern)\n\n   \n## 架构模式\n* MVC\n* MVVM\n* MVP\n \n## 算法\n\n### 多线程与锁\n* 锁\n   * OSSptionLock\n      * 自旋锁\n      * 循环等待询问，不释放当前资源\n      * 用于轻量级的数据访问，简单的int值操作\n   * dispath_semaphore\n   * pthread_mutex\n   * 细粒度 NSLock\n   * pthread_mutex(recursive)\n   * NSRecursiveLock\n   * @synchronized (一般在创建单例对象的时候使用)\n*  atomic\n   * 可修饰关键字\n   * 对被修饰的关键字进行原子操作（不负责使用）"}]