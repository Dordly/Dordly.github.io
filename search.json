[{"url":"/2018/08/10/IOS各类常用判断/","content":"##IOS各类常用判断\n\n#####  1、改变按钮倒计时与状态\n\n```\n+(void)changeVerifyButtonState:(UIButton *)sender\n{\n    __block int countDown = 120;\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\n    dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);\n    dispatch_source_set_event_handler(timer, ^{\n        if(countDown <= 0)\n        {\n            //倒计时结束，关闭\n            dispatch_source_cancel(timer);\n            dispatch_async(dispatch_get_main_queue(), ^{\n                //设置界面的按钮显示\n                sender.enabled = YES;\n                sender.backgroundColor = Main_Color;\n                [sender setTitle:@\"重新获取验证码\" forState:UIControlStateNormal];\n            });\n        }\n        else\n        {\n            NSString *TimeString = [NSString stringWithFormat:@\"%.2d\", countDown];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [sender setTitle:[NSString stringWithFormat:@\"%@秒再次获取\",TimeString] forState:UIControlStateNormal];\n                sender.backgroundColor = MainTwoText_Color;\n                sender.enabled = NO;\n            });\n            countDown--;\n        }\n    });\n    dispatch_resume(timer);\n}\n```\n\n##### 2、过滤所有Emoji标签符号\n\n```\n/**过滤所有Emoji标签符号*/\n+(BOOL)stringContainEmoji:(NSString *)emoji{\n    __block BOOL returnValue = NO;\n    [emoji enumerateSubstringsInRange:NSMakeRange(0, [emoji length]) options:NSStringEnumerationByComposedCharacterSequences usingBlock:\n     ^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {\n         const unichar hs = [substring characterAtIndex:0];\n         // surrogate pair\n         if (0xd800 <= hs && hs <= 0xdbff) {\n             if (substring.length > 1) {\n                 const unichar ls = [substring characterAtIndex:1];\n                 const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;\n                 if (0x1d000 <= uc && uc <= 0x1f77f) {\n                     returnValue = YES;\n                 }\n             }\n         } else if (substring.length > 1) {\n             const unichar ls = [substring characterAtIndex:1];\n             if (ls == 0x20e3) {\n                 returnValue = YES;\n             }\n         } else {\n             // non surrogate\n             if (0x2100 <= hs && hs <= 0x27ff) {\n                 returnValue = YES;\n             } else if (0x2B05 <= hs && hs <= 0x2b07) {\n                 returnValue = YES;\n             } else if (0x2934 <= hs && hs <= 0x2935) {\n                 returnValue = YES;\n             } else if (0x3297 <= hs && hs <= 0x3299) {\n                 returnValue = YES;\n             } else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50) {\n                 returnValue = YES;\n             }\n         }\n     }];\n    return returnValue;\n}\n```\n\n##### 3、判断手机格式\n```\n+(BOOL)validateWithMobile:(NSString *)mobile\n{\n    NSString * phone = @\"^1([3-9]\\\\d{9}$)\";\n    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",phone];\n    return [phoneTest evaluateWithObject:mobile];\n}\n```\n##### 4、判断姓名格式\n```\n+(BOOL)validateUserName:(NSString *)name\n{\n    NSString *userNameRegex = @\"^[A-Za-z0-9]{3,20}+$\";\n    NSPredicate *userNamePredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",userNameRegex];\n    BOOL B = [userNamePredicate evaluateWithObject:name];\n    return B;\n}\n```\n##### 5、判断输入昵称\n```\n+(BOOL)validateNickname:(NSString *)nickname\n{\n    NSString *nicknameRegex = @\"^[\\u4E00-\\u9FA5\\uf900-\\ufa2d·s•]{2,20}$\";\n    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",nicknameRegex];\n    return [passWordPredicate evaluateWithObject:nickname];\n}\n```\n##### 6、判断邮箱格式\n```\n+(BOOL)ValidateEmail:(NSString *)email {\n    NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\";\n    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex];\n    return [emailTest evaluateWithObject:email];\n}\n```\n##### 7、判断字符串首字符是否为字母\n```\n+(BOOL)JudgeString:(NSString *)string{\n    NSString *regex = @\"[A-Za-z]+\";\n    NSPredicate*predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex];\n    return [predicate evaluateWithObject:string];\n}\n```\n##### 8、时间戳转时间\n```\n/**1.时间戳转换成时间*/\n+ (NSString *)dateWithString:(NSString *)str Format:(NSString *)format\n{\n    NSTimeInterval time = [str doubleValue];\n    /** [[NSDate date] timeIntervalSince1970]*1000;*/\n    NSDate *detaildate = [NSDate dateWithTimeIntervalSince1970:time];\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];//实例化一个NSDateFormatter对象\n    [dateFormatter setDateFormat:format];//设定时间格式,这里可以设置成自己需要的格式\n    NSString *currentDateStr = [dateFormatter stringFromDate:detaildate];\n    return currentDateStr;\n}\n/**2.时间戳转换时间-毫秒*/\n+ (NSString *)dateMSWithString:(NSString *)str Format:(NSString *)format\n{\n    NSTimeInterval time = [str doubleValue]/1000;\n    /** [[NSDate date] timeIntervalSince1970]*1000;*/\n    NSDate *detaildate = [NSDate dateWithTimeIntervalSince1970:time];\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];//实例化一个NSDateFormatter对象\n    [dateFormatter setDateFormat:format];//设定时间格式,这里可以设置成自己需要的格式\n    NSString *currentDateStr = [dateFormatter stringFromDate:detaildate];\n    return currentDateStr;\n}\n/**3.转换成时间*/\n+(NSString *)dateWithDate:(NSDate *)date Format:(NSString *)format\n{\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];//实例化一个NSDateFormatter对象\n    [dateFormatter setDateFormat:format];//设定时间格式,这里可以设置成自己需要的格式\n    NSString *currentDateStr = [dateFormatter stringFromDate:date];\n    return currentDateStr;\n}\n/**4.当前时间戳转换成时间*/\n+ (NSString *)currentDateWithFormat:(NSString *)format\n{\n    NSDate *detaildate = [NSDate date];\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];//实例化一个NSDateFormatter对象\n    [dateFormatter setDateFormat:format];//设定时间格式,这里可以设置成自己需要的格式\n    NSString *currentDateStr = [dateFormatter stringFromDate:detaildate];\n    return currentDateStr;\n}\n```\n##### 9、时间戳转星期\n```\n+(NSString*)getWeekDay:(NSString*)currentStr\n{\n    NSDateFormatter* dateFormat = [[NSDateFormatter alloc]init];\n    [dateFormat setDateFormat:@\"yyyy-MM-dd\"];\n    NSDate*date =[dateFormat dateFromString:currentStr];\n    NSArray*weekdays = [NSArray arrayWithObjects: [NSNull null],@\"星期日\",@\"星期一\",@\"星期二\",@\"星期三\",@\"星期四\",@\"星期五\",@\"星期六\",nil];\n    NSCalendar*calendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSCalendarIdentifierGregorian];\n    NSTimeZone*timeZone = [[NSTimeZone alloc]initWithName:@\"Asia/Shanghai\"];\n    [calendar setTimeZone: timeZone];\n    NSCalendarUnit calendarUnit =NSCalendarUnitWeekday;\n    NSDateComponents*theComponents = [calendar components:calendarUnit fromDate:date];\n    return [weekdays objectAtIndex:theComponents.weekday];\n}\n```\n##### 10、 NSString转NSDate\n```\n+ (NSDate *)dateWithdate:(NSString *)str Format:(NSString *)format\n{\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];//实例化一个NSDateFormatter对象\n    [dateFormatter setDateFormat:format];//设定时间格式,这里可以设置成自己需要的格式\n    NSDate * mainDate = [dateFormatter dateFromString:str];\n    return mainDate;\n}\n```\n##### 11、 判断系统通知是否打开\n```\n+(BOOL)openThePushNotification{\n    if (IOS8) {//IOS8写的宏\n        if ([[UIApplication sharedApplication] currentUserNotificationSettings].types  == UIUserNotificationTypeNone) {\n            //         未打开通知//这个是个自定义的alertView 当用户没有打开推送时  会弹出 可以替换成自己项目里面的弹框\n            if (IOS8) {//iOS8以后跳转到设置界面的代码也出现了变化 下面这段代码是直接跳转到APP的设置界面\n                //跳入当前App设置界面\n                [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];\n            }else{\n                //适配iOS7 ,跳入系统设置界面\n                [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"prefs:General&path=Reset\"]];\n            }\n            return NO;\n        }else{\n            return YES;\n        }\n    }else{ // ios7\n        if ([[UIApplication sharedApplication] enabledRemoteNotificationTypes]  == UIUserNotificationTypeNone) {\n            if (IOS8) {\n                //跳入当前App设置界面\n                [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];\n            }else{\n                //适配iOS7 ,跳入系统设置界面\n                [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"prefs:General&path=Reset\"]];\n            }\n            return NO;\n        }else{\n            \n            return YES;\n        }\n    }\n}\n```\n##### 12、获取手机型号\n```\n+ (NSString *)deviceVersion\n{\n    struct utsname systemInfo;\n    \n    uname(&systemInfo);\n    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];\n    if ([platform isEqualToString:@\"iPhone5,1\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,2\"]) return @\"iPhone 5\";\n    if ([platform isEqualToString:@\"iPhone5,3\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone5,4\"]) return @\"iPhone 5c\";\n    if ([platform isEqualToString:@\"iPhone6,1\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone6,2\"]) return @\"iPhone 5s\";\n    if ([platform isEqualToString:@\"iPhone7,1\"]) return @\"iPhone 6 Plus\";\n    if ([platform isEqualToString:@\"iPhone7,2\"]) return @\"iPhone 6\";\n    if ([platform isEqualToString:@\"iPhone8,1\"]) return @\"iPhone 6s\";\n    if ([platform isEqualToString:@\"iPhone8,2\"]) return @\"iPhone 6s Plus\";\n    if ([platform isEqualToString:@\"iPhone8,4\"]) return @\"iPhone SE\";\n    if ([platform isEqualToString:@\"iPhone9,1\"]) return @\"iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,3\"]) return @\"iPhone 7\";\n    if ([platform isEqualToString:@\"iPhone9,2\"]) return @\"iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone9,4\"]) return @\"iPhone 7 Plus\";\n    if ([platform isEqualToString:@\"iPhone10,1\"]) return @\"iPhone 8\";\n    if ([platform isEqualToString:@\"iPhone10,4\"]) return @\"iPhone 8\";\n    if ([platform isEqualToString:@\"iPhone10,2\"]) return @\"iPhone 8 Plus\";\n    if ([platform isEqualToString:@\"iPhone10,5\"]) return @\"iPhone 8 Plus\";\n    if ([platform isEqualToString:@\"iPhone10,3\"]) return @\"iPhone X\";\n    if ([platform isEqualToString:@\"iPhone10,6\"]) return @\"iPhone X\";\n    if ([platform isEqualToString:@\"i386\"])      return @\"iPhone Simulator\";\n    if ([platform isEqualToString:@\"x86_64\"])    return @\"iPhone Simulator\";\n    \n    return platform;\n}\n```\n##### 13、字典转JSON\n```\n/**\n *  字典转JSON\n */\n+ (NSString *)dictionaryToJson:(NSDictionary *)dict\n{\n    BOOL isValidJSONObject = [NSJSONSerialization isValidJSONObject:dict];\n    if (isValidJSONObject)\n    {\n        NSData *jsonData =  [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];\n        return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n    }\n    return nil;\n}\n/*\n * JSON转字典\n */\n+ (NSDictionary *)jsonToDictionary:(NSString *)jsonString\n{\n    if (jsonString == nil)\n    {\n        return nil;\n    }\n//    NSLog(@\"%@\",jsonString);\n    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];\n    NSError *err;\n    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData\n                                                        options:NSJSONReadingMutableContainers\n                                                          error:&err];\n    if(err) {\n//        NSLog(@\"json解析失败：%@\",err);\n        return nil;\n    }\n    return dic;\n}\n```\n##### 14、判断银行卡是否合法\n```\n+(BOOL)checkBankCardNumber:(NSString *)cardNumber\n{\n    int oddSum = 0;     // 奇数和\n    int evenSum = 0;    // 偶数和\n    int allSum = 0;     // 总和\n    \n    // 循环加和\n    for (NSInteger i = 1; i <= cardNumber.length; i++)\n    {\n        NSString *theNumber = [cardNumber substringWithRange:NSMakeRange(cardNumber.length-i, 1)];\n        int lastNumber = [theNumber intValue];\n        if (i%2 == 0)\n        {\n            // 偶数位\n            lastNumber *= 2;\n            if (lastNumber > 9)\n            {\n                lastNumber -=9;\n            }\n            evenSum += lastNumber;\n        }\n        else\n        {\n            // 奇数位\n            oddSum += lastNumber;\n        }\n    }\n    allSum = oddSum + evenSum;\n    // 是否合法\n    if (allSum%10 == 0)\n    {\n        return YES;\n    }\n    else\n    {\n        return NO;\n    }\n}\n```\n##### 15、过滤指定字符\n```\n+(NSString*)RemoveSpecialCharacter: (NSString *)str {\n    NSRange urgentRange = [str rangeOfCharacterFromSet: [NSCharacterSet characterSetWithCharactersInString: @\",.？、 ~￥#&<>《》()[]{}【】^@/￡¤|§¨「」『』￠￢￣~@#&*（）——+|《》$_€\"]];\n    if (urgentRange.location != NSNotFound)\n    {\n        return [self RemoveSpecialCharacter:[str stringByReplacingCharactersInRange:urgentRange withString:@\"\"]];\n    }\n    return str;\n}\n```\n##### 16、判断密码格式\n```\n+(BOOL)validateWithPassword:(NSString *)password\n{\n    //密码只包含字母，数字，字符中至少两种\n    NSString * regex = @\"^(?![0-9]+$)(?![a-zA-Z]+$)[a-zA-Z0-9]{6,18}$\";\n    NSPredicate * pas= [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex];\n    return [pas evaluateWithObject:password];\n}\n```\n##### 17、字符串替换\n```\n+(NSString *)StringChooseString:(NSString *)chooseStr{\n    NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@\"@／：；（）¥「」＂、[]{}#%-*+=_\\\\|~＜＞$€^•'@#$%^&*()_+'\\\".\"];\n    NSString *trimmedString = [chooseStr stringByTrimmingCharactersInSet:set];\n//    NSLog(@\"DELECT----%@\",trimmedString);\n    NSString *str = [trimmedString stringByReplacingOccurrencesOfString:@\"\\\",\" withString:@\"、\"];//替换字符\n    NSString * twoStr = [str stringByReplacingOccurrencesOfString:@\"\\\"\" withString:@\"\"];\n    NSString * three = [twoStr stringByReplacingOccurrencesOfString:@\".\" withString:@\"\"];\n//    NSLog(@\"DELECTONE----%@\",three);\n    return three;\n}\n```\n##### 18、字典按升序排序\n```\n+ (NSString *)stringWithAscendingOrderDict:(NSDictionary*)dict\n{\n    NSArray*keys = [dict allKeys];\n    NSArray*sortedArray = [keys sortedArrayUsingComparator:^NSComparisonResult(id obj1,id obj2)\n                           {\n                               return[obj1 compare:obj2 options:NSNumericSearch];//正序\n                           }];\n    NSString*str =@\"\";\n    for(NSString*categoryId in sortedArray)\n    {\n        id value = [dict objectForKey:categoryId];\n        if ([value isKindOfClass:[NSDictionary class]])\n        {\n            value = [self stringWithAscendingOrderDict:value];\n        }\n        if ([str length] !=0)\n        {\n            str = [str stringByAppendingString:@\"&\"];\n        }\n        str = [str stringByAppendingFormat:@\"%@=%@\",categoryId,value];\n    }\n    return str;\n}\n```\n\n##### 19、图片压缩\n```\n+ (UIImage *)imageWithImage:(UIImage *)image scaledToSize:(CGSize)size {\n    UIGraphicsBeginImageContext(size);\n    [image drawInRect:CGRectMake(0, 0, size.width, size.height)];\n    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return newImage;\n}\n```\n\n##### 20、显示原生弹框\n```\n+ (void)showInfo:(NSString *)info VC:(UIViewController *)VC\n{\n    UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@\"温馨提示\" message:info preferredStyle:UIAlertControllerStyleAlert];\n    UIAlertAction *okAction = [UIAlertAction actionWithTitle:@\"确定\" style:UIAlertActionStyleDefault handler:nil];\n    [alertVC addAction:okAction];\n    [VC presentViewController:alertVC animated:YES completion:nil];\n}\n```\n\n##### 21、匹配身份证号码\n```\n+ (BOOL)matchesWithIDCardNumber:(NSString *)idNumber\n{\n    return [self matchesWithFormatString:@\"^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$|^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$\" tagaetStr:idNumber];\n}\n```\n\n##### 22、每隔4个字符添加一个空格的字符串算法\n```\n+ (NSString *)dealWithString:(NSString *)number\n{\n    NSString *doneTitle = @\"\";\n    int count = 0;\n    for (int i = 0; i < number.length; i++) {\n        \n        count++;\n        doneTitle = [doneTitle stringByAppendingString:[number substringWithRange:NSMakeRange(i, 1)]];\n        if (count == 4) {\n            doneTitle = [NSString stringWithFormat:@\"%@ \", doneTitle];\n            count = 0;\n        }\n    }\n//    NSLog(@\"%@\", doneTitle);\n    return doneTitle;\n}\n```\n\n##### 23、字符串转拼音\n```\n+(NSString *)transformToPinyin:(NSString *)aString\n{\n    //转成了可变字符串\n    NSMutableString *str = [NSMutableString stringWithString:aString];\n    CFStringTransform((CFMutableStringRef)str,NULL, kCFStringTransformMandarinLatin,NO);\n    \n    //再转换为不带声调的拼音\n    CFStringTransform((CFMutableStringRef)str,NULL, kCFStringTransformStripDiacritics,NO);\n    NSArray *pinyinArray = [str componentsSeparatedByString:@\" \"];\n    NSMutableString *allString = [NSMutableString new];\n    \n    int count = 0;\n    \n    for (int  i = 0; i < pinyinArray.count; i++)\n    {\n        for(int i = 0; i < pinyinArray.count;i++)\n        {\n            if (i == count) {\n                [allString appendString:@\"#\"];\n                //区分第几个字母\n            }\n            [allString appendFormat:@\"%@\",pinyinArray[i]];\n        }\n        [allString appendString:@\",\"];\n        count ++;\n    }\n    NSMutableString *initialStr = [NSMutableString new];\n    //拼音首字母\n    for (NSString *s in pinyinArray)\n    {\n        if (s.length > 0)\n        {\n            [initialStr appendString:  [s substringToIndex:1]];\n        }\n    }\n    [allString appendFormat:@\"#%@\",initialStr];\n    [allString appendFormat:@\",#%@\",aString];\n    return allString;\n}\n```\n\n##### 24、判断字符串是否为整形，若字符串是一个字符，则判断是否是数字\n```\n+ (BOOL) deptNumInputShouldNumber:(NSString *)str\n{\n    if (str.length == 0) {\n        return NO;\n    }\n    NSString *regex = @\"[0-9]*\";\n    NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\",regex];\n    if ([pred evaluateWithObject:str]) {\n        return YES;\n    }\n    return NO;\n}\n```\n\n[地址](https://github.com/Dordly/ValidateString.git)\n"},{"url":"/2018/07/31/IOS知识点汇总/","content":"# IOS知识点汇总\n## 第三方开源项目\n### 响应式编程\n* [Swift-ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n* [RxSwift](https://github.com/ReactiveX/RxSwift)\n\n#### [AFNetworking -- 功能非常齐全的网络数据请求库，侧重于处理各种类型的api风格,提供了远程图片异步加载，上传下载等常用功能，如果项目数据量很小它会是很好的选择](https://github.com/AFNetworking/AFNetworking)\n* POST\n* GET\n\n#### [SDWebImage -- 图片异步加载](https://github.com/rs/SDWebImage)\n\n* 特点\n   * 不阻塞主线程\n   * 异步加载图片，不重复获取图片URL\n   * 后台图片解压缩\n   * 高性能\n   * 使用GCD和ARC\n   * 支持多种图片格式，包括GIF\n   * 提供 UIImageView, UIButton, MKAnnotationView 的分类，用来显示网络图片，以及缓存管理\n   * 异步缓存（内存+磁盘），并且自动管理缓存有效性\n \n ***\n   * 使用方法，常用：UIImageView+WebCache\n ```\n [self.imageView sd_setImageWithURL:[NSURL URLWithString:@\"图片链接\"] placeholderImage:[UIImage imageNamed:@\"默认图片\"]];\n ```\n \n   * 使用回调 blocks\n   \n  ```\n  [self.imageView sd_setImageWithURL:[NSURL URLWithString:@\"图片链接\"]\n                      placeholderImage:[UIImage imageNamed:@\"默认图片\"]\n                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {\n                                 ... completion code here ...\n                             }];\n  ```\n  \n   *  SDWebImageManager 的使用(将图片下载和图片缓存组合起来了,也可以单独使用)\n\n   ```\n   SDWebImageManager *manager = [SDWebImageManager sharedManager];\n[manager loadImageWithURL:imageURL\n                      options:0\n                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {\n                         // progression tracking code\n                     }\n                    completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {\n                        if (image) {\n                            // do something with image\n                        }\n                    }];\n   ```\n   \n   * 使用 SDWebImageDownloader 异步下载图片(单独使用，图片不会缓存)\n\n   ```\n   SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];\n[downloader downloadImageWithURL:imageURL\n                             options:0\n                            progress:^(NSInteger receivedSize, NSInteger expectedSize) {\n                                // progression tracking code\n                            }\n                           completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {\n                               if (image && finished) {\n                                   // do something with image\n                               }\n                           }];\n   ```\n   \n   * 使用 SDImageCache 异步缓存图片(单独使用时，可使用单例，也可以创建一个有独立命名空间的 SDImageCache 实例)\n      * 添加缓存\n      \n   ```\n   [[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];\n   ```\n   \n      * 默认情况下，图片数据会同时缓存到内存和磁盘中，如果你想只要内存缓存的话\n      \n      ```\n      [[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey toDisk:NO];\n      ```\n      * 读取缓存时可以使用 queryDiskCacheForKey:done: 方法，图片缓存的 key 是唯一的，通常就是图片的 absolute URL\n\n      ```\n      SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@\"myNamespace\"];\n[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image) {\n        // image is not nil if image was found\n    }];\n      ```\n ***\n\n#### [OC-GPUImage -- 做滤镜最主流的开源框架](https://github.com/BradLarson/GPUImage)\n\n***\n* GPUImage中的几个概念(output为输出源,intput为输入源,filter为滤镜)\n   * #import \"GPUImageBrightnessFilter.h\"                //亮度\n   * #import \"GPUImageExposureFilter.h\"                  //曝光\n   * #import \"GPUImageContrastFilter.h\"                  //对比度\n   * #import \"GPUImageSaturationFilter.h\"                //饱和度\n   * #import \"GPUImageGammaFilter.h\"                     //伽马线\n   * #import \"GPUImageColorInvertFilter.h\"               //反色\n   * #import \"GPUImageSepiaFilter.h\"                     //褐色（怀旧）\n   * #import \"GPUImageLevelsFilter.h\"                    //色阶\n   * #import \"GPUImageGrayscaleFilter.h\"                 //灰度\n   * #import \"GPUImageHistogramFilter.h\"                 //色彩直方图，显示在图片上\n   * #import \"GPUImageHistogramGenerator.h\"              //色彩直方图\n   * #import \"GPUImageRGBFilter.h\"                       //RGB\n   * #import \"GPUImageToneCurveFilter.h\"                 //色调曲线\n   * #import \"GPUImageMonochromeFilter.h\"                //单色\n   * #import \"GPUImageOpacityFilter.h\"                   //不透明度\n   * #import \"GPUImageHighlightShadowFilter.h\"           //提亮阴影\n   * #import \"GPUImageFalseColorFilter.h\"                //色彩替换（替换亮部和暗部色彩）\n   * #import \"GPUImageHueFilter.h\"                       //色度\n   * #import \"GPUImageChromaKeyFilter.h\"                 //色度键\n   * #import \"GPUImageWhiteBalanceFilter.h\"              //白平横\n   * #import \"GPUImageAverageColor.h\"                    //像素平均色值\n   * #import \"GPUImageSolidColorGenerator.h\"             //纯色\n   * #import \"GPUImageLuminosity.h\"                      //亮度平均\n   * #import \"GPUImageAverageLuminanceThresholdFilter.h\" //像素色值亮度平均，图像黑白（有类似漫画效果）\n   * #import \"GPUImageLookupFilter.h\"                    //lookup 色彩调整\n   * #import \"GPUImageAmatorkaFilter.h\"                  //Amatorka lookup\n   * #import \"GPUImageMissEtikateFilter.h\"               //MissEtikate lookup\n   * #import \"GPUImageSoftEleganceFilter.h\"              //SoftElegance lookup\n   * #import \"GPUImageCrosshairGenerator.h\"              //十字\n   * #import \"GPUImageLineGenerator.h\"                   //线条\n   * #import \"GPUImageTransformFilter.h\"                 //形状变化\n   * #import \"GPUImageCropFilter.h\"                      //剪裁\n   * #import \"GPUImageSharpenFilter.h\"                   //锐化\n   * #import \"GPUImageUnsharpMaskFilter.h\"               //反遮罩锐化\n   * #import \"GPUImageFastBlurFilter.h\"                  //模糊\n   * #import \"GPUImageGaussianBlurFilter.h\"              //高斯模糊\n   * #import \"GPUImageGaussianSelectiveBlurFilter.h\"     //高斯模糊，选择部分清晰\n   * #import \"GPUImageBoxBlurFilter.h\"                   //盒状模糊\n   * #import \"GPUImageTiltShiftFilter.h\"                 //条纹模糊，中间清晰，上下两端模糊\n   *  #import \"GPUImageMedianFilter.h\"                    //中间值，有种稍微模糊边缘的效果\n   * #import \"GPUImageBilateralFilter.h\"                 //双边模糊\n   * #import \"GPUImageErosionFilter.h\"                   //侵蚀边缘模糊，变黑白\n   * #import \"GPUImageRGBErosionFilter.h\"                //RGB侵蚀边缘模糊，有色彩\n   * #import \"GPUImageDilationFilter.h\"                  //扩展边缘模糊，变黑白\n   * #import \"GPUImageRGBDilationFilter.h\"               //RGB扩展边缘模糊，有色彩\n   * #import \"GPUImageOpeningFilter.h\"                   //黑白色调模糊\n   * #import \"GPUImageRGBOpeningFilter.h\"                //彩色模糊\n   * #import \"GPUImageClosingFilter.h\"                   //黑白色调模糊，暗色会被提亮\n   * #import \"GPUImageRGBClosingFilter.h\"                //彩色模糊，暗色会被提亮\n   * #import \"GPUImageLanczosResamplingFilter.h\"         //Lanczos重取样，模糊效果\n   * #import \"GPUImageNonMaximumSuppressionFilter.h\"     //非最大抑制，只显示亮度最高的像素，其他为黑\n   * #import \"GPUImageThresholdedNonMaximumSuppressionFilter.h\" //与上相比，像素丢失更多\n   * #import \"GPUImageSobelEdgeDetectionFilter.h\"        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)\n   * #import \"GPUImageCannyEdgeDetectionFilter.h\"        //Canny边缘检测算法（比上更强烈的黑白对比度）\n   * #import \"GPUImageThresholdEdgeDetectionFilter.h\"    //阈值边缘检测（效果与上差别不大）\n   * #import \"GPUImagePrewittEdgeDetectionFilter.h\"      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)\n   * #import \"GPUImageXYDerivativeFilter.h\"              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色\n   * #import \"GPUImageHarrisCornerDetectionFilter.h\"     //Harris角点检测，会有绿色小十字显示在图片角点处\n   * #import \"GPUImageNobleCornerDetectionFilter.h\"      //Noble角点检测，检测点更多\n   * #import \"GPUImageShiTomasiFeatureDetectionFilter.h\" //ShiTomasi角点检测，与上差别不大\n   * #import \"GPUImageMotionDetector.h\"                  //动作检测\n   * #import \"GPUImageHoughTransformLineDetector.h\"      //线条检测\n   * #import \"GPUImageParallelCoordinateLineTransformFilter.h\" //平行线检测\n   * #import \"GPUImageLocalBinaryPatternFilter.h\"        //图像黑白化，并有大量噪点\n   * #import \"GPUImageLowPassFilter.h\"                   //用于图像加亮\n   * #import \"GPUImageHighPassFilter.h\"                  //图像低于某值时显示为黑\n   * #import \"GPUImageSketchFilter.h\"                    //素描\n   * #import \"GPUImageThresholdSketchFilter.h\"           //阀值素描，形成有噪点的素描\n   * #import \"GPUImageToonFilter.h\"                      //卡通效果（黑色粗线描边）\n   * #import \"GPUImageSmoothToonFilter.h\"                //相比上面的效果更细腻，上面是粗旷的画风\n   * #import \"GPUImageKuwaharaFilter.h\"                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用\n   * #import \"GPUImageMosaicFilter.h\"                    //黑白马赛克\n   * #import \"GPUImagePixellateFilter.h\"                 //像素化\n   * #import \"GPUImagePolarPixellateFilter.h\"            //同心圆像素化\n   * #import \"GPUImageCrosshatchFilter.h\"                //交叉线阴影，形成黑白网状画面\n   * #import \"GPUImageColorPackingFilter.h\"              //色彩丢失，模糊（类似监控摄像效果）\n   * #import \"GPUImageVignetteFilter.h\"                  //晕影，形成黑色圆形边缘，突出中间图像的效果\n   * #import \"GPUImageSwirlFilter.h\"                     //漩涡，中间形成卷曲的画面\n   * #import \"GPUImageBulgeDistortionFilter.h\"           //凸起失真，鱼眼效果\n   * #import \"GPUImagePinchDistortionFilter.h\"           //收缩失真，凹面镜\n   * #import \"GPUImageStretchDistortionFilter.h\"         //伸展失真，哈哈镜\n   * #import \"GPUImageGlassSphereFilter.h\"               //水晶球效果\n   * #import \"GPUImageSphereRefractionFilter.h\"          //球形折射，图形倒立\n   * #import \"GPUImagePosterizeFilter.h\"                 //色调分离，形成噪点效果\n   * #import \"GPUImageCGAColorspaceFilter.h\"             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面\n   * #import \"GPUImagePerlinNoiseFilter.h\"               //柏林噪点，花边噪点\n   * #import \"GPUImage3x3ConvolutionFilter.h\"            //3x3卷积，高亮大色块变黑，加亮边缘、线条等\n   * #import \"GPUImageEmbossFilter.h\"                    //浮雕效果，带有点3d的感觉\n   * #import \"GPUImagePolkaDotFilter.h\"                  //像素圆点花样\n   * #import \"GPUImageHalftoneFilter.h\"                  //点染,图像黑白化，由黑点构成原图的大致图形\n   * #import \"GPUImageMultiplyBlendFilter.h\"             //通常用于创建阴影和深度效果\n   * #import \"GPUImageNormalBlendFilter.h\"               //正常\n   * #import \"GPUImageAlphaBlendFilter.h\"                //透明混合,通常用于在背景上应用前景的透明度\n   * #import \"GPUImageDissolveBlendFilter.h\"             //溶解\n   * #import \"GPUImageOverlayBlendFilter.h\"              //叠加,通常用于创建阴影效果\n   * #import \"GPUImageDarkenBlendFilter.h\"               //加深混合,通常用于重叠类型\n   * #import \"GPUImageLightenBlendFilter.h\"              //减淡混合,通常用于重叠类型\n   * #import \"GPUImageSourceOverBlendFilter.h\"           //源混合\n   * #import \"GPUImageColorBurnBlendFilter.h\"            //色彩加深混合\n   * #import \"GPUImageColorDodgeBlendFilter.h\"           //色彩减淡混合\n   * #import \"GPUImageScreenBlendFilter.h\"               //屏幕包裹,通常用于创建亮点和镜头眩光\n   * #import \"GPUImageExclusionBlendFilter.h\"            //排除混合\n   * #import \"GPUImageDifferenceBlendFilter.h\"           //差异混合,通常用于创建更多变动的颜色\n   * #import \"GPUImageSubtractBlendFilter.h\"             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果\n   * #import \"GPUImageHardLightBlendFilter.h\"            //强光混合,通常用于创建阴影效果\n   * #import \"GPUImageSoftLightBlendFilter.h\"            //柔光混合\n   * #import \"GPUImageChromaKeyBlendFilter.h\"            //色度键混合\n   * #import \"GPUImageMaskFilter.h\"                      //遮罩混合\n   * #import \"GPUImageHazeFilter.h\"                      //朦胧加暗\n   * #import \"GPUImageLuminanceThresholdFilter.h\"        //亮度阈\n   * #import \"GPUImageAdaptiveThresholdFilter.h\"         //自适应阈值\n   * #import \"GPUImageAddBlendFilter.h\"                  //通常用于创建两个图像之间的动画变亮模糊效果\n   * #import \"GPUImageDivideBlendFilter.h\"               //通常用于创建两个图像之间的动画变暗模糊效果\n   * #import \"c.h\"\n   * #import \"GPUImageVoroniConsumerFilter.h\"\n\n***\n\n#### [Swift-GPUImage](https://github.com/BradLarson/GPUImage2)\n\n#### [Masonry -- 自动约束](https://github.com/SnapKit/Masonry)\n##### 采用链式编程的方法\n***\n* mas_makeConstraints()    添加约束\n* mas_remakeConstraints()  移除之前的约束，重新添加新的约束（ __调用此方法的时候，使用了如下API__）\n   * - (void)setNeedsLayout  标记为需要重新布局\n   * - (void)layoutIfNeeded  查看当前视图是否被标记需要重新布局，有则在内部调用layoutSubviews方法进行重新布局\n   * - (void)layoutSubviews  重写当前方法，在内部完成重新布局操作\n\n   \n* mas_updateConstraints()  更新约束（ __调用此方法时所使用到的API如下__ ）\n   * - (void)updateConstraintsIfNeeded  调用此方法，如果有标记为需要重新布局的约束，则立即进行重新布局，内部会调用updateConstraints方法\n   * - (void)updateConstraints          重写此方法，内部实现自定义布局过程\n   * - (BOOL)needsUpdateConstraints     当前是否需要重新布局，内部会判断当前有没有被标记的约束\n   * - (void)setNeedsUpdateConstraints  标记需要进行重新布局\n\n***\n##### 注：在使用Masonry添加约束的时候，一定要在addSubview之后再使用，要不然会引起程序的崩溃现象\n\n####[RestKit -- 注重从远程数据请求到本地数据解析的存储和流程化业务处理，它专注于RESTful API，如果你项目服务器不是RESTful，那就别考虑了](https://github.com/RestKit/RestKit)\n* 解析json和映射对象\n* Network :RestKit现在使用AFNetworking v1.3.3作为网络操作层，RestKit的维护者正在升级到AFNetworking 2.0\n* Object Mapping(对象映射): RestKit提供一个接口来直接映射服务器返回的json/xml数据\n* Core Data:RestKit对coreData提供了额外的支持，包括映射远程对象为coreData对象并且进行本地存储\n\n***\n* RKObjectManager是和RESTful services交互的核心,需要一个AFHTTPClient实例来进行初始化。\n\n* RKObjectMapping是用来配置JSON和本地model的映射信息，如果json和本地的model中都有name这个字段，你又需要解析这个字段，那么就要通过addAttributeMappingsFromArray进行添加。\n\n* RKResponseDescriptor描述了对HTTP返回数据的映射信息。pathPattern 就是api的具体路径，会被添加到baseURL后面。keyPath 是对象在json数据中的路径。看看上面的json数据,@“response.venues”说明了对象venue所处的逻辑位置，并告诉RestKit去哪找venue。\n\n***\n\n\n\n#### [YYKit](https://github.com/ibireme/YYKit)\n\n* [YYModel — 高性能的 iOS JSON 模型框架。](https://github.com/ibireme/YYModel)\n* [YYCache — 高性能的 iOS 缓存框架。](https://github.com/ibireme/YYCache)\n* [YYImage — 功能强大的 iOS 图像框架。](https://github.com/ibireme/YYImage)\n* [YYWebImage — 高性能的 iOS 异步图像加载框架。](https://github.com/ibireme/YYWebImage)\n* [YYText — 功能强大的 iOS 富文本框架。](https://github.com/ibireme/YYText)\n* [YYKeyboardManager — iOS 键盘监听管理工具。](https://github.com/ibireme/YYKeyboardManager)\n* [YYDispatchQueuePool — iOS 全局并发队列管理工具。](https://github.com/ibireme/YYDispatchQueuePool)\n* [YYAsyncLayer — iOS 异步绘制与显示的工具。](https://github.com/ibireme/YYAsyncLayer)\n* [YYCategories — 功能丰富的 Category 类型工具库。](https://github.com/ibireme/YYCategories)\n\n#### [FMDB -- 数据库](https://github.com/ccgus/fmdb)\n__对libsqlite3库的封装__\n\n#### [RESideMenu -- 侧滑栏](https://github.com/romaonthego/RESideMenu)\n\n#### [UITableView - FDTemplateLayoutCell -- 缓存cell高度-自适应](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)\n__可与Masonry搭配使用__\n\n#### [IQKeyBoardManager -- 自定义键盘](https://github.com/hackiftekhar/IQKeyboardManager)\n\n#### [WMPageController -- 自定义滚动菜单栏](https://github.com/wangmchn/WMPageController)\n\n#### [LemonBubble -- 自定义弹框样式](https://github.com/LemonITCN/LemonBubble)\n\n#### [MJRefresh -- 刷新加载](https://github.com/CoderMJLee/MJRefresh)\n\n### JSON\n* MJExtension\n* JSONModel\n* YYModel\n\n\n### XML\n* Ono\n* GDataXML\n* XMLDictionary\n* hpple\n* KissXML\n\n## 工具\n### IDE\n* Xcode\n* Appcode\n\n### Xcode插件\n* AMMethod2Implement\n* Alcatraz\n* ClangFormat\n* Auto-Importer\n* CocoaPods\n* ESJsonFormat\n* FuzzyAutocimplete\n* KSHObjcUML\n* KSImageNamed\n* OMColorSense\n* RTImageAssets\n* SCXcodeSwitchExpander\n* VVDocumenter-Xcode\n* Lin\n* XAlign\n* HOStringSense\n* XToDo\n* XcodeBoost\n* BBUDebuggerTuckAway\n* InjectionPlugin\n\n### 调试工具\n* 界面\n   * Reveal\n   * Xcode内置的View Debugging\n* 网络\n   * WireShark\n   * Charles\n   * Network Link Condidtioner\n   * HTTPScoop\n   * PonyDebugger\n\n### 数据分析工具\n* 数据库\n   * SQLiteBrowser\n   * Navicat\n   * Datum\n* JSON\n   * Jason\n   * VisualJson\n   * json.cn\n\n### 文档工具\n* Dash\n* Xcode内置的Documentation And API Reference\n\n### 应用程序图标\n* APPIcon\n* IconKit\n* Image 2 Icon Tool\n\n### 界面原型\n* Sketch\n* 墨刀\n* Briefs\n* Axure RP\n\n### 性能分析\n* Instruments\n   * Allocations\n   * Network\n   * Leaks\n   * Time Profiler\n   * Zombie\n\n### 包管理工具\n* CocoaPods\n* Carthage\n* Swift Package Manager\n\n### 版本控制\n* Git\n   * SourceTree\n   * Github Desktop\n   * GitUp \n* Mercurial\n* SVN\n   * CornerStone\n\n### 编辑工具\n* Markdown\n   * MacDown\n   * Haroopad\n   * Typora\n   * MWeb\n* 文本编辑器\n   * Atom\n   * Sublime Text\n   * Visual Studio Code\n\n### 翻墙工具\n* Lantern\n* Shadowsocks\n* GoAgentX\n* Surge\n\n### 辅助工具\n* Unarchiver\n* 截图工具\n   * GIFBrewery\n   * Snip\n   * LICEcap\n* 图片处理\n   * PhotoShop\n   * PixeImator\n* Sip\n* XScope\n* 思维导图\n   * MindNode\n   * Xmind\n* 马克鳗\n* 文本比较\n   * DiffMerge\n   * Beyond Compare\n* ImageOptim\n* Deploymate\n* FauxPas\n* 0xED\n* UML/在线UML\n### 命令行工具\n* xcodebuild\n* xcode-select\n* brew\n* xctool\n* fastlane\n* git-flow\n* tree\n\n## 第三方服务\n### BasS(后端即服务)\n* LeanCloud\n* Bomb\n* 七牛\n* 环信\n* 融云\n* 友盟\n* CloudKit\n* 极光推送\n* Flurry\n* Google Analytics\n* MTA\n* App Annie\n\n### 崩溃收集\n* Crashlytics\n* Bugly\n* BugHD\n\n### 内测分发\n* 蒲公英\n* FIR\n* TestFlight\n\n## 持续集成\n* Travis CI\n* Circle CI\n* Coveralls\n* Codecov\n* Fastlane(自动化发布流程)\n\n## 编程语言\n* C/C++\n* Objective-C\n* Swift\n* HTML5\n* JavaScript\n\n## 操作系统\n* macOS\n* ios\n* WatchOS\n* TV OS\n* Linus常用命令\n\n## 开发基础\n### Objective-C\n* Block\n* 类的设计\n   * Self\n   * 属性\n   * 组合\n   * 重写\n   * 继承\n   * 多态\n   * Category\n   * Extension\n   * Protocol\n   * Class\n   * SEL\n* 文件管理\n* 内存管理\n   * MRC\n   * ARC\n* 数据持久化\n   * XML\n   * Plist\n   * 归档\n   * CoreData & SQLite\n   * JSON\n* KVC&KVO\n* Foundation\n\n\n### Swift\n* 基本运算符\n* 字符串和字符\n* 集合类型\n* 控制流\n* 函数\n* 闭包\n* 枚举\n* 类和结构体\n* 属性\n* 方法\n* 下标脚本\n* 继承\n* 构造过程\n* 析构过程\n* 自动引用计数\n* 可空链式调用\n* 错误处理\n* 类型转换\n* 嵌套类型\n* 扩展\n* 协议\n* 泛型\n* 访问控制\n\n\n### UI\n* UIResponder\n   * UIApplication\n   * UIView\n      * MapKit\n         * MKAnnotationView\n         * MKMapView\n         * MKOverlayView\n         * MPVolumeView\n      * UIKit\n         * UIActionSheet\n         * UIAlertView\n         * UIActivityInndicatorView\n         * UIControl\n            * UIDatePicker\n            * UIButton\n            * UIPageControl\n            * UIRefreshControl\n            * UISegmentedControl\n            * UISlider\n            * UIStepper\n            * UISwitch\n            * UITextField\n         * UIInputView\n         * UIImageView\n         * UILabel\n         * UINavigationBar\n         * UIPopoverBackgroundView\n         * UIPickerView\n         * UIProgressView\n         * UIScrollView\n            * UICollectionView\n            * UITableView\n            * UITextView -- UITextField\n         * UISearchBar\n         * UIStackView\n         * UITabBar\n         * UITableViewCell\n         * UITableView\bHeaderFooterView\n         * UIToolBar\n         * UIWebView\n         * UIVisualEffectView\n         * UIWindow\n      * WebKit - WKWebView\n   * UIViewController\n      * AddressBookUI\n         * ABNewPersonViewController\n         * ABPersonViewController\n         * ABUnknownPersonViewController\n      * UIKit\n         * UIActivityViewController\n         * UIAlertController\n         * UICollectionViewController\n         * UISearchContainerViewController\n         * UIInputViewController\n         * UINavigationController -- UIImagePickerController\n         * UIPageViewController\n         * UISearchController\n         * UISplitViewController\n         * UITabBarController\n         * UIPopoverController(非继承)\n         * UITableViewController\n         * UISearchDisplayController (非继承)\n         * UIMenuController (非继承)\n      * AVKit\n         * AVPlayerViewController\n         * AVPictureInPictureController (非继承)\n* Storyboard & Xib\n   * Auto Layout\n      * SnapKit\n      * Masonry\n   * Size Classes\n* Core Graphics\n* Core Animation\n* 手势识别\n   * UIPanGestureRecognizer -- 平移/慢速移动手势\n   * UILongPressGestureRecognizer -- 长按手势\n   * UIPinchGestureRecognizer -- 捏合手势\n   * UIRotationGestureRecognizer -- 旋转手势\n   * UITapGestureRecognizer  -- 点击手势\n   * UISwipGestureRecognizer  -- 滑动/移动手势\n\n```\n#import \"FourthViewController.h\"\n\n@interface FourthViewController ()<UIGestureRecognizerDelegate>\n\n@property (nonatomic, strong)UIImageView * imageView;\n@end\n\n@implementation FourthViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [super setNavigationBarColor:Main_Color title:@\"发现\" TitleColor:Color_white];\n    \n    self.imageView = insertAutoImage(self.view, Img_Name(@\"gep\"), Color_clear);\n    [self.imageView mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.view.mas_left).offset(60);\n        make.right.equalTo(self.view.mas_right).offset(-60);\n        make.bottom.equalTo(self.view.mas_bottom).offset(-60);\n        make.top.equalTo(self.view.mas_top).offset(60);\n    }];\n    \n    //允许和用户之间进行交互\n    self.imageView.userInteractionEnabled = YES;\n    //添加手势\n    //1.旋转手势\n    UIRotationGestureRecognizer * gestureOne = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(gestureClick:)];\n    gestureOne.delegate = self;\n    [self.imageView addGestureRecognizer:gestureOne];\n    \n    //2.捏合手势\n    UIPinchGestureRecognizer * gestureTwo = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(gestureTwoClick:)];\n    gestureTwo.delegate = self;\n    [self.imageView addGestureRecognizer:gestureTwo];\n    \n    //3.滑动手势\n    UISwipeGestureRecognizer * gestureThree1 = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(gestureThreeClick:)];\n    gestureThree1.direction = UISwipeGestureRecognizerDirectionRight;\n    [self.imageView addGestureRecognizer:gestureThree1];\n    \n    UISwipeGestureRecognizer * gestureThree2 = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(gestureThreeClick:)];\n    gestureThree2.direction = UISwipeGestureRecognizerDirectionLeft;\n    [self.imageView addGestureRecognizer:gestureThree2];\n    \n    //4.点击手势\n    UITapGestureRecognizer * gestureFour = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(gestureFourClick:)];\n    gestureFour.numberOfTapsRequired = 1;//点击次数\n    [self.imageView addGestureRecognizer:gestureFour];\n    \n    //5.长按手势\n    UILongPressGestureRecognizer * gestureFif = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(gestureFifClick:)];\n    gestureFif.minimumPressDuration = 1;//长按时间\n    [self.view addGestureRecognizer:gestureFif];\n    \n}\n#pragma mark - 旋转手势 -\n- (void)gestureClick:(UIRotationGestureRecognizer *)sender {\n    self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, sender.rotation);\n    sender.rotation = 0;//每次旋转完后清0，防止叠加\n}\n#pragma mark - 捏合手势 -\n- (void)gestureTwoClick:(UIPinchGestureRecognizer *)sender {\n    self.imageView.transform = CGAffineTransformScale(self.imageView.transform, sender.scale, sender.scale);\n    sender.scale = 1;\n}\n#pragma mark - 滑动手势 -\n- (void)gestureThreeClick:(UISwipeGestureRecognizer *)sender {\n    if (sender.direction == UISwipeGestureRecognizerDirectionRight) {\n        self.imageView.center = CGPointMake(SCREEN_WIDTH/2+20, SCREEN_HEIGHT/2);\n    }\n    if (sender.direction == UISwipeGestureRecognizerDirectionLeft) {\n        self.imageView.center = CGPointMake(SCREEN_WIDTH/2-20, SCREEN_HEIGHT/2);\n    }\n}\n#pragma mark - 点击手势 -\n- (void)gestureFourClick:(UITapGestureRecognizer *)sender {\n    //点击放大/缩小图片\n    [self.imageView mas_updateConstraints:^(MASConstraintMaker *make) {\n        make.left.equalTo(self.view.mas_left).offset(10);\n        make.right.equalTo(self.view.mas_right).offset(-10);\n        make.bottom.equalTo(self.view.mas_bottom).offset(-10);\n        make.top.equalTo(self.view.mas_top).offset(10);\n    }];\n}\n#pragma mark - 长按手势 -\n- (void)gestureFifClick:(UILongPressGestureRecognizer *)sender {\n    //获取长按的位置在屏幕上对应的点\n    CGPoint point  = [sender locationInView:self.view];\n    self.imageView.center = point;\n}\n//返回YES表示同时支持识别多个手势\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{\n    return YES;\n    \n}\n@end\n```\n\n### 网络\n* Socket\n   * CocoaAsyncSocket\n   * WebSocket -- SocketRocket\n* 网络协议\n   * TCP\n   * UDP\n   * HTTP\n   * HTTPS\n* NSURLSession\n* NSURLConnection\n* CFNetwork\n* NSSream\n### 多线程\n* pThread\n* NSThread\n* GCD\n   * 同步\n   * 异步\n   * 串行\n   * 并发\n* NSTunLoop\n* NSOperationQueue\n\n\n### 测试\n* 断点调试\n* LLDB\n* GDB\n* NSZombieEnabled\n* Instruments\n* Unit Tests\n* UI Tests\n\n\n### 数据存储\n* Plist -- NSUserDefaults\n* NSCoder\n* SQLite -- CoreData\n   * 特点\n      * 1.是基于c语言开发的数据库\n      * 2.用c语言对数据库执行操作，访问。\n      * 3.sqlite是动态的数据库类型，即存储的时候是一种类型，使用的时候可以存储为其他类型。\n      * 4.建立连接之后可以不关闭连接\n* Realm\n* KeyChain\n\n## Frameworks\n### 常用框架\n* 音视频\n   * AudioToolbox\n   * AVFoundation\n   * AVKit\n   * CoreAudio\n   * CoreAudioKit\n   * MediaPlayer\n* 定位地图\n   * CoreLocation\n   * MapKit\n* 网页\n   * WebKit\n   * JavaScript Core\n      * WebViewJavaScriptBridge\n      * Wax\n      * JSPatch\n* 通讯录\n   * AddressBook\n   * AddressBookUI\n* 相册\n   * AssetsLibrary\n* 数据存储\n   * CoreData\n   * CloudKit\n* 图文混排\n   * CoreText\n* 本地验证\n   * LocalAuthentication\n* 支付\n   * StoreKit\n   * PassKit\n\n   \n### 高级框架\n* 智能家居\n   * Home Kit\n* 健康\n   * Health Kit\n* 广告\n   * AdSupport\n   * iAd\n* 硬件开发\n   * MutilpeerConnectivity\n   * CoreBluetooth\n   * CoreMotion\n* 游戏开发\n   * GameKit\n   * SpriteKit\n* 绘图\n   * CoreGrapthics(2D)\n   * QuartzCore\n   * SceneKit(3D)\n   * Metal\n\n## 开发进阶\n### Runtime\n### 对象模型\n### 逆向与安全\n* 转码技术\n   * URL Encode\n   * Base64 Encode\n* 密码技术\n   * 对称密码\n      * DES/3DES\n      * AES\n   * 公钥密码\n      * RSA\n   * 单向散列函数\n      * MD5\n      * SHA\n         * SHA-1\n         * SHA-224\n         * SHA-256\n         * SHA-384\n         * SHA-512\n      * HMAC\n      * PBKDF2\n\n### Hybrid\n* PhoneGap\n* React Native\n* ionic\n\n\n### 打包与封装\n* App Thinning\n* 动态库 .dylib\n* 框架 .framework\n* 静态库 .a\n* 资源包 .bundle\n\n\n## 设计模式\n### 面向对象三要素\n* 封装\n* 继承\n* 多态\n\n\n### 面向对象七原则\n* L:里式替换原则\n* S:单一职责原则\n* I:接口隔离原则\n* O:开放封闭原则\n* D:依赖倒置原则\n* 迪米特法则 -- 最少知道原则\n* 合成聚合复用原则\n\n\n### 23种设计模式(四人帮)\n* 创建型模式\n   * 工厂模式(Factory Pattern)\n   * 抽象工厂模式(Abstract Factory Pattern)\n   * 单例模式(Singleton Pattern)\n   * 建造者模式(Builder Pattern)\n   * 原型模式(Prototype Pattern)\n* 结构型模式\n   * 适配器模式(Adapter Pattern)\n   * 桥接模式(Bridge Pattern)\n   * 组合模式(Composite Pattern)\n   * 过滤器模式(Filter、Criteria Pattern)\n   * 装饰器模式(Decorator Pattern)\n   * 外观模式(Facade Pattern)\n   * 享元模式(Flyweight Pattern)\n   * 代理模式(Proxy Pattern)\n* 行为型模式\n   * 责任链模式(Chain of Responsibility Pattern)\n   * 命令模式(Command Pattern)\n   * 解释器模式(Interpreter Pattern)\n   * 迭代器模式(Iterator Pattern)\n   * 中介者模式(Mediator Pattern)\n   * 备忘录模式(Memento Pattern)\n   * 观察者模式(Observer Pattern)\n   * 空对象模式(Null Object Pattern)\n   * 状态模式(State Pattern)\n   * 策略模式(Strategy Pattern)\n   * 模板模式(Template Pattern)\n   * 访问者模式(Visitor Pattern)\n\n   \n## 架构模式\n* MVC\n* MVVM\n* MVP\n \n## 算法\n\n### 多线程与锁\n* 锁\n   * OSSptionLock\n      * 自旋锁\n      * 循环等待询问，不释放当前资源\n      * 用于轻量级的数据访问，简单的int值操作\n   * dispath_semaphore\n   * pthread_mutex\n   * 细粒度 NSLock\n   * pthread_mutex(recursive)\n   * NSRecursiveLock\n   * @synchronized (一般在创建单例对象的时候使用)\n*  atomic\n   * 可修饰关键字\n   * 对被修饰的关键字进行原子操作（不负责使用）"}]